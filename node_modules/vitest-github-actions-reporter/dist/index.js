// src/index.ts
import {
  startGroup,
  endGroup,
  error
} from "@actions/core";

// src/stacktrace/parse.ts
import path from "node:path";
var stackIgnorePatterns = [
  "node:internal",
  /\/packages\/\w+\/dist\//,
  /\/@vitest\/\w+\/dist\//,
  "/vitest/dist/",
  "/vitest/src/",
  "/vite-node/dist/",
  "/vite-node/src/",
  "/node_modules/chai/",
  "/node_modules/tinypool/",
  "/node_modules/tinyspy/"
];
var slash = (str) => str.replace(/\\/g, "/");
var resolve = (str) => slash(path.resolve(str));
function notNullish(v) {
  return v != null;
}
function extractLocation(urlLike) {
  if (!urlLike.includes(":"))
    return [urlLike];
  const regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
  const parts = regExp.exec(urlLike.replace(/[()]/g, ""));
  if (!parts)
    return [urlLike];
  return [parts[1], parts[2] || void 0, parts[3] || void 0];
}
function parseSingleStack(raw) {
  let line = raw.trim();
  if (line.includes("(eval "))
    line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
  let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
  const location = sanitizedLine.match(/ (\(.+\)$)/);
  sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
  const [url, lineNumber, columnNumber] = extractLocation(
    location ? location[1] : sanitizedLine
  );
  let method = location && sanitizedLine || "";
  let file = url && ["eval", "<anonymous>"].includes(url) ? void 0 : url;
  if (!file || !lineNumber || !columnNumber)
    return null;
  if (method.startsWith("async "))
    method = method.slice(6);
  if (file.startsWith("file://"))
    file = file.slice(7);
  file = resolve(file);
  return {
    method,
    file,
    line: parseInt(lineNumber),
    column: parseInt(columnNumber)
  };
}
var parseStacktrace = (stackStr, full = false) => {
  const stackFrames = stackStr.split("\n").map((raw) => {
    const stack = parseSingleStack(raw);
    if (!stack || !full && stackIgnorePatterns.some((p) => stack.file.match(p)))
      return null;
    return stack;
  }).filter(notNullish);
  return stackFrames;
};

// src/stacktrace/stringify.ts
var repository = process.env.GITHUB_WORKSPACE;
var repositoryPrefixes = repository ? [repository.replace(/\/?$/, "/")] : [];
var stringifyStacktrace = (stack, trimRepositoryPrefix) => {
  return stack.map((s) => {
    let file = s.file;
    if (trimRepositoryPrefix && repositoryPrefixes.length > 0) {
      file = trimPrefixes(file, repositoryPrefixes);
    }
    return `  at ${s.method ? `${s.method} ` : ""}${file}:${s.line}:${s.column}`;
  }).join("\n");
};
var trimPrefixes = (str, prefixes) => {
  for (const p of prefixes) {
    if (str.startsWith(p)) {
      str = str.slice(p.length);
      break;
    }
  }
  return str;
};

// src/index.ts
var GitHubActionsReporter = class {
  ctx;
  options;
  constructor({
    trimRepositoryPrefix = true,
    hideStackTrace = false
  } = {}) {
    this.options = {
      trimRepositoryPrefix,
      hideStackTrace
    };
  }
  onInit(ctx) {
    this.ctx = ctx;
  }
  async onFinished(files) {
    if (!files)
      return;
    startGroup("Vitest Annotations");
    this.reportFiles(files);
    endGroup();
  }
  reportFiles(files) {
    for (const file of files) {
      this.reportTaskErrors(file.filepath, file);
      this.reportTasks(file.filepath, file.tasks);
    }
  }
  reportTasks(filename, tasks) {
    for (const task of tasks) {
      if (task.type === "suite") {
        this.reportTaskErrors(filename, task);
        this.reportTasks(filename, task.tasks);
      } else if (task.type === "test") {
        this.reportTaskErrors(filename, task);
      } else if (task.type === "custom") {
      } else {
        checkNever(task);
      }
    }
  }
  reportTaskErrors(filename, task) {
    var _a;
    for (const err of ((_a = task.result) == null ? void 0 : _a.errors) ?? []) {
      this.reportTaskError(task.type, filename, err);
    }
  }
  reportTaskError(taskType, filename, err) {
    const stackTrace = this.parseStacktrace(err.stackStr);
    const position = this.getPositionFromError(filename, stackTrace);
    const message = this.createMessage(stackTrace);
    error(message, {
      ...position,
      title: this.getErrorTitle(
        err,
        `Failed ${taskType[0].toUpperCase()}${taskType.slice(1)}`
      )
    });
  }
  parseStacktrace(stacktraceStr) {
    if (!stacktraceStr)
      return void 0;
    return parseStacktrace(stacktraceStr);
  }
  createMessage(stacktrace) {
    if (this.options.hideStackTrace)
      return ".";
    if (!stacktrace)
      return "No stacktrace";
    return stringifyStacktrace(stacktrace, this.options.trimRepositoryPrefix);
  }
  getPositionFromError(filename, stacktrace) {
    if (!stacktrace || !stacktrace[0]) {
      return { file: filename };
    }
    const { file, line, column } = stacktrace[0];
    return {
      file,
      startLine: line,
      startColumn: column
    };
  }
  getErrorTitle(error2, fallback) {
    return `${(error2 == null ? void 0 : error2.name) ?? "Error"}: ${(error2 == null ? void 0 : error2.message) ?? fallback}`;
  }
};
function checkNever(_) {
}
export {
  GitHubActionsReporter as default
};
/*!
  https://github.com/vitest-dev/vitest/blob/f1cdfb6960a1eb39345f973529bc1e72ab4090b4/packages/vitest/src/utils/source-map.ts#L59-L115
  MIT License
  Copyright (c) 2021-Present Anthony Fu <https://github.com/antfu>
  Copyright (c) 2021-Present Matias Capeletto <https://github.com/patak-dev>
  https://github.com/vitest-dev/vitest/blob/main/LICENSE
*/
//# sourceMappingURL=index.js.map